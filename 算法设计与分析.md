# 算法设计与分析

### 翻转问题

时间复杂度为O（n），空间复杂度为O（1）

算法：先翻转（1，k），再翻转（k+1，n）

再翻转（1，n）



### 微博名人问题

简单的思路就是两层遍历，第i层外循环的任务是判断第i个是不是名人，而内循环就是问其他人有没有关注第i个人。

而改进的思路是这样的，随便抽两个人A和B，问A是否关注了B。

- A关注了B，则A不是名人，删除A
- A没关注B，则B不是名人，删除B

一直删到只剩下一个人的时候，该人就是候选名人，一次循环判断该唯一的候选名人是不是名人即可，复杂度Θ(n)。



### 最大连续子序列

- 递归方法

  以middle为界限分开，==左边最大的为***leftmax***，右边最大的***rightmax***==（递归）， ***midmax***为middle从左到右的最大值，最后比较三个值的大小

- 动态规划方法

  *动态规划直观的思想就是保存中间有用的结果，并通过调整计算的顺序，来消除冗余的步骤。*

  先考虑子问题：**求解以第i个元素结尾的最大子序列的和**，i从1到n。

  求这些子问题得到的中间结果是值得保存的，假设保存在数组MaxSum[1,…,n]中

  状态转移方程是MaxSum[i]=max{MaxSum[i−1]+A[i],A[i]}

  这样每次状态转移都是O(1)的代价，MaxSum填满需要O(n)代价，那么在MaxSum中遍历一遍找到最大值即是最大连续子序列的和。

  用动态规划时间复杂度是O(n)。





### 快速排序

```c++
PARTITION(A,p,r)
  pivot:=A[r];
	i=p-1;
	for j=p to r-1 do
    	if A[j]<pivot then
        i++;
				swap(A[i],A[j]);
	swap(A[i+1],A[r]);
	return i+1;
```

```c++
QUICK_SORT(A,p,r)
  if p<r then
    q=PARTITION(A,p,r);
		QUICK_SORT(A,p,q-1);
		QUICK_SORT(A,q+1,r);
```



### 动态发现中位数

​	构造一个最大堆和最小堆



### 选次大元素的问题

​	第一次的时间复杂度的下界是n-1；第二次是logn的上界-1（每一层都有备选，log n上界为备选的数量）



### 哈希表

​	负载因子=$\frac{n}{m}$,n为数据的个数，m为哈希表的位置

![截屏2021-07-03 下午1.55.27](/Users/mac/Library/Application Support/typora-user-images/截屏2021-07-03 下午1.55.27.png)

### 并查集的时间复杂度

​	基于矩阵和数组，union和find操作有l个，数字有n个，时间复杂度为O（nl）



### 平摊分析

C~amo~(平摊代价)=C~act~(实际代价)+C~acc~(记账代价)



### 对手论证

​	一般使用反证，给出小于多少次可能会信息不足，导致错误。

​	锦标赛（金币策略）

### DFS树(有向图)

- TE：遍历u时，如果他的邻居v为白色，uv为TE
- BE：遍历u时，如果他的邻居已经被访问到，且为他的祖先时，uv为BE
- DE：遍历u时，如果他的邻居已经被访问到，且为他的后继时，uv为DE

- CE：其他情况就是CE

无向图中没有DE和CE

### 寻找割点

​	v，dfs遍历他的邻居w，如果w.back>=v.discovertiome，则w是割点，如果小于，则说明有wx（BE），x是v的祖先结点。（等于的话去掉点不连通）

​	所以说，寻找割点的算法就是看有没有BE

### 寻找桥

​		w.back>v.discovertiome和寻找割点类似（等于的话，去掉边也连通）



### 给无向图的边定向

​	使得每个点的入度至少为1

- 最外层for循环，遍历每个白色的顶点
- 循环体中第一次dfs找BE，若找不到则算法返回无解；若找到则以BE的任意端点作为顶点进行第二次dfs，遍历边时进行定向。
- 每个顶点最多访问2次，复杂度线性。

算法正确性

- 若没有BE，则边数小于点数，入度必然小于点数，不可能定向成功
- 若有BE，则非根节点的入边来自于父亲，根节点的入边来自于BE



### 桥和割点问题

​	大多都是和BE有关的证明

​	定向问题也是找BE，然后再做一次DFS，共计两次DFS

8.20题（2）：topo序最小的点开始运用（1）的算法



### 影响力问题 

​	两次DFS先转换成收缩图，然后用一次DFS看每个收缩图能到达的顶点的个数，对应强连通片里的所有点都为最大/最小影响力的图



### 小孩排队问题

​	找入度为0的点，然后删除那些边，然后不断更新入度，把入度为0的点加进去



### 有向图的广度优先遍历 

- 不可能有DE





### 无向图的BFS

​	没有DE和BE



### 染色问题

一个点在v1，一个点在v2



### k度子图问题

​	找度小于k的点，删除这个点和与他相联的边，直到删除完毕，最后为子图。代价为O（m+n）



### 检查是否有环

- DFS
  - 有向图，遇到灰色节点（BE）
  - 无向图，遇到灰色节点（BE）
- BFS
  - 有向图，发现黑色的祖先（BE），但注意发现邻居是黑色节点不一定代表遇到BE，也可能是CE，还要额外检查是不是祖先。
  - 无向图，遇到灰色节点（CE）

答案中只需要给出：DFS检测有向图的环、BFS检测无向图的环即可。





### 最小生成树

- BFS找无向图的圈，9.5问已经说明过，线性代价
- 删除圈上权重最大的边，此时不改变图的连通性，线性代价
- 将上述两个步骤重复11次，即删除11条边，剩下的边数m是点数减1，此连通图即最小生成树
- 复杂度线性



- 首先只考虑权重为1的边，用BFS框架进行遍历，得到宽度优先遍历森林。如果森林中只有一颗树，则该树就是原图的最小生成树，开销线性。
- 否则构造一个新图，对森林的每棵树初始化一个顶点。遍历权重为2的边，如果边的两端点不在森林的同一颗树上，则把这两颗树所对应的新图的两个顶点之间连上权重为1的边，并记录该边对应哪一条权重为2的边（如果对应多条，只需要记录其中一条）。开销线性。
- 用BFS框架遍历该新图，得到新图的最小生成树。开销线性。
- 宽度优先遍历森林的所有边（权重为1）在最小生成树上。
- 新图的最小生成树上的边所对应的（权重为2）边在最小生成树上。
- 总时间开销是线性的。



先把权为1的边加入，再加入连接两棵树的权为2的边



### MST

最小生成树MST，加上一条边e形成环，这条边是环中最大的



### 切

​	V1、V2的并为全集，交为空集，V1、V2构成图G的一个切

MCE：跨越切的最小边

### 确定e在不在一个最小生成树中

- 记e两端点是uv，删除所有权值大于等于e的边。
- 从u出发搜索v
  - 如果能搜到，说明e是某环上唯一的最重边，不可能在最小生成树上
  - 如果搜不到，反设e不在任意最小生成树上，则任意最小生成树加上e都会形成圈，且e是圈上唯一的最重边（否则e和同重的边替换即可得到一个最小生成树）。因此u会搜到v，矛盾。因此e在某个最小生成树上。



### 井和管道问题

- 第一问：生成最小生成树铺设管道，在最小造价的节点打井
- 第二问
  - 想象有一个水源节点，打井的代价可以开作是从水源节点运水的管道代价。
  - 那么问题可以这样转化，新加一个水源节点，连向每个房子。管道造价为原图的打井代价。对新图生成MST。MST上原图有的边对应管道代价，原图没的边对应打井代价。

新加一个节点，连接每个点，代价为每个结点打井的代价，然后找到最小生成树



### 图中有一条负权边的图的dijkstra

- 设负边为uv，权重为w
- 删除uv，以s、u、v为起点，调用三次Dijkstra算法，结果为dists[], distu[], distv[]。
- 对于s到t的最短路径，dist[t]=min{dists[t], dists[u]+w+distv[t],dists[v]+w+distu[t]}



### 油箱问题

- 第一问：把权值大于L的边删去，从s出发dfs搜t即可，线性复杂度。
- 第二问：
  - 给每个点定义变量capacity：从s到该点的所有路径上最大边权值的最小值
  - 初始化：s的capacity为0,其他点的capacity为无穷。
  - 每次选择与最短路径树相邻的且capcity值最小的点，加入最小路径树。第一步把s加入。
  - 每次向最短路径树增加一个点u后，更新其邻居v的capacity
  - ***v.capacity=min{v.capacity, max{u.capacity,uv.weight}}***
  - 返回第三行继续选点加入最小路径树。
  - 最终t.capacity就是从s到t的最小油箱容量。
  - 复杂度同Dijkstra,O((m+n)log n)



### 相容任务调度问题

​	基于任务结束时间的贪心算法



### 最长连续子序列

liss[i]为以i结尾的最长的子序列的个数，

状态转移方程为liss[i]=max（max(j<i&&A[j]<=A[i])liss[i]+1，1）

最后遍历一遍找出最大值

### 最长公共子序列

- 以C[i,j]表示x中前i个构成的串，和y中前j个构成的串的最长公共子序列

- 则

  C[i,j]=

  - 0，若i=0 || j=0
  - C[i−1,j−1]+1，若i,j>0 && xi=yj
  - max{C[i,j−1],C[i−1,j]}，若i,j>0 && xi≠yj

![截屏2021-07-04 下午2.23.54](/Users/mac/Library/Application Support/typora-user-images/截屏2021-07-04 下午2.23.54.png)





### NP完全性证明

​	先说明这个问题是NP问题（猜测一个解，多项式时间可验证），再证明一个NP问题能够规约到这个问题，即证明他是NP难问题，又是NP问题又是NP难问题，得证。